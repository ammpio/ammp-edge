use std::path::Path;

use typify::{TypeSpace, TypeSpaceSettings};

const CONFIG_SCHEMA_PATH: &str = "../json-schema/config.schema.json";
const DRIVER_SCHEMA_PATH: &str = "../json-schema/driver.schema.json";
const DATA_SCHEMA_PATH: &str = "../json-schema/data.schema.json";

fn main() {
    println!("cargo:rerun-if-changed={CONFIG_SCHEMA_PATH}");
    println!("cargo:rerun-if-changed={DRIVER_SCHEMA_PATH}");
    println!("cargo:rerun-if-changed={DATA_SCHEMA_PATH}");

    // Generate config types
    generate_types_from_schema(
        CONFIG_SCHEMA_PATH,
        "src/config.rs",
        "Config types from config.schema.json",
    );

    // Generate standalone driver types
    generate_types_from_schema(
        DRIVER_SCHEMA_PATH,
        "src/driver.rs",
        "Driver types from driver.schema.json",
    );

    // Generate standalone data schema
    generate_types_from_schema(
        DATA_SCHEMA_PATH,
        "src/data.rs",
        "Data types from data.schema.json",
    );
}

fn generate_types_from_schema(schema_path: &str, output_path: &str, description: &str) {
    let schema_file = Path::new(schema_path);
    let output_file = Path::new(output_path);

    // Read and parse the JSON schema
    let schema_content = std::fs::read_to_string(schema_file)
        .unwrap_or_else(|e| panic!("Failed to read schema file {}: {}", schema_path, e));

    let schema: schemars::schema::RootSchema = serde_json::from_str(&schema_content)
        .unwrap_or_else(|e| panic!("Failed to parse schema file {}: {}", schema_path, e));

    // Generate Rust types
    let mut settings = TypeSpaceSettings::default();
    settings.with_derive("Clone".to_string());
    settings.with_derive("PartialEq".to_string());

    if schema_path == DATA_SCHEMA_PATH {
        settings.with_map_type("std::collections::BTreeMap".to_string());
    }

    let mut type_space = TypeSpace::new(&settings);
    type_space
        .add_root_schema(schema)
        .unwrap_or_else(|e| panic!("Failed to process schema {}: {}", schema_path, e));

    // Write generated code
    let contents = format!(
        "// {}\n// This file is automatically generated by build.rs\n// DO NOT EDIT MANUALLY\n\n{}\n",
        description,
        prettyplease::unparse(&syn::parse2(type_space.to_stream()).unwrap())
    );

    let final_contents = match schema_path {
        DRIVER_SCHEMA_PATH => post_process_driver_rs(contents),
        DATA_SCHEMA_PATH => post_process_data_rs(contents),
        CONFIG_SCHEMA_PATH => post_process_config_rs(contents),
        _ => contents,
    };

    std::fs::write(output_file, final_contents)
        .unwrap_or_else(|e| panic!("Failed to write output file {}: {}", output_path, e));
}

fn post_process_driver_rs(content: String) -> String {
    // Convert all i64 types to u8 types
    // This handles the case where JSON schema has "type": "integer", "format": "u8"

    content
        .replace("i64", "u8")
        .replace("::std::num::NonZeroU64", "::std::num::NonZeroU16")
}

fn post_process_data_rs(content: String) -> String {
    // Replace i64 with u8 in StatusReading
    content.replace("pub l: i64", "pub l: u8")
}

fn post_process_config_rs(content: String) -> String {
    let mut modified_content = content;

    // Add import for DriverSchema and Typecast at the file level (after the header comments)
    if let Some(pos) = modified_content.find("/// Error types.") {
        let import_line = "use crate::driver::{DriverSchema, Typecast};\n\n";
        modified_content.insert_str(pos, import_line);
    }

    // Find and replace the drivers field type
    // Replace the specific pattern we found: pub drivers: ::serde_json::Map<::std::string::String, ::serde_json::Value>
    let old_drivers_type =
        "pub drivers: ::serde_json::Map<::std::string::String, ::serde_json::Value>";
    let new_drivers_type =
        "pub drivers: ::std::collections::HashMap<::std::string::String, DriverSchema>";

    if modified_content.contains(old_drivers_type) {
        modified_content = modified_content.replace(old_drivers_type, new_drivers_type);
    }

    // Also fix the serde annotation for the drivers field
    let old_serde_attr = "#[serde(default, skip_serializing_if = \"::serde_json::Map::is_empty\")]";
    let new_serde_attr =
        "#[serde(default, skip_serializing_if = \"::std::collections::HashMap::is_empty\")]";

    if modified_content.contains(old_serde_attr) {
        modified_content = modified_content.replace(old_serde_attr, new_serde_attr);
    }

    // Remove the duplicate Typecast enum from config.rs
    modified_content = remove_typecast_enum(modified_content);

    modified_content
}

fn remove_typecast_enum(content: String) -> String {
    let lines: Vec<&str> = content.lines().collect();

    let mut start_line_to_remove = None;
    let mut end_line_to_remove = None;

    // Find the line where the FULL content is "///Typecast of output" (not indented)
    for (i, line) in lines.iter().enumerate() {
        if *line == "///Typecast of output" {
            start_line_to_remove = Some(i);
            break;
        }
    }

    // Find the line that states "/// Generation of default values for serde."
    if let Some(start_line) = start_line_to_remove {
        for (i, line) in lines.iter().enumerate().skip(start_line) {
            if *line == "/// Generation of default values for serde." {
                end_line_to_remove = Some(i);
                break;
            }
        }
    }

    if let (Some(start_line), Some(end_line)) = (start_line_to_remove, end_line_to_remove) {
        // Remove from start_line to just before end_line (preserve the defaults module)
        let mut result_lines = Vec::new();
        result_lines.extend_from_slice(&lines[..start_line]);
        result_lines.extend_from_slice(&lines[end_line..]);

        // Add a final newline if the original content had one
        if content.ends_with('\n') {
            return result_lines.join("\n") + "\n";
        } else {
            return result_lines.join("\n");
        }
    }

    content
}
