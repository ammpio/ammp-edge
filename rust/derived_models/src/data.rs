// Data types from data.schema.json
// This file is automatically generated by build.rs
// DO NOT EDIT MANUALLY

/// Error types.
pub mod error {
    /// Error from a `TryFrom` or `FromStr` implementation.
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
///This is the structure of data payloads submitted to the MQTT broker.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "$id": "https://github.com/ammpio/edge-schema/raw/main/data.schema.json",
///  "title": "Data payload",
///  "description": "This is the structure of data payloads submitted to the MQTT broker.",
///  "type": "object",
///  "required": [
///    "r",
///    "t"
///  ],
///  "properties": {
///    "m": {
///      "title": "Metadata",
///      "examples": [
///        {
///          "config_id": "3e43652",
///          "reading_duration": 93.77299094200134,
///          "snap_rev": 721
///        }
///      ],
///      "type": "object",
///      "properties": {
///        "config_id": {
///          "title": "Configuration ID",
///          "examples": [
///            "3e43652"
///          ],
///          "type": "string"
///        },
///        "data_provider": {
///          "title": "Data provider",
///          "examples": [
///            "sma-hycon-csv"
///          ],
///          "type": "string"
///        },
///        "reading_duration": {
///          "title": "Duration of reading",
///          "examples": [
///            93.77299094200134
///          ],
///          "type": "number"
///        },
///        "snap_rev": {
///          "title": "Snap revision",
///          "examples": [
///            721
///          ],
///          "type": "integer"
///        }
///      }
///    },
///    "r": {
///      "title": "Readings",
///      "type": "array",
///      "items": {
///        "title": "Device data",
///        "examples": [
///          {
///            "_d": "logger",
///            "_vid": "strato-1",
///            "boot_time": 1660737617.0,
///            "cpu_load": 0.1,
///            "memory_usage": 22.4
///          },
///          {
///            "_d": "diesel_sensor",
///            "_vid": "gamicos-1",
///            "analog": 4.0,
///            "genset_fuel_level_percent": 100.0,
///            "genset_fuel_volume": 3048.625,
///            "level": 0.0
///          }
///        ],
///        "type": "object",
///        "required": [
///          "_vid"
///        ],
///        "properties": {
///          "_d": {
///            "title": "Device key",
///            "examples": [
///              "logger",
///              "apm303",
///              "sma_stp1",
///              "dse855"
///            ],
///            "type": "string"
///          },
///          "_vid": {
///            "title": "Device vendor ID",
///            "description": "Vendor ID of device (must match vendor_id in device table",
///            "examples": [
///              "strato-1",
///              "imt-1",
///              "7a7fcafa-6f07-4c97-9b10-952aad8e9dc4",
///              "35346907"
///            ],
///            "type": "string"
///          }
///        },
///        "additionalProperties": {
///          "type": [
///            "integer",
///            "number",
///            "string",
///            "boolean",
///            "null"
///          ]
///        }
///      }
///    },
///    "t": {
///      "title": "Timestamp (Unix epoch seconds)",
///      "examples": [
///        1660757423
///      ],
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct DataPayload {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub m: ::std::option::Option<Metadata>,
    pub r: ::std::vec::Vec<DeviceData>,
    pub t: i64,
}
impl ::std::convert::From<&DataPayload> for DataPayload {
    fn from(value: &DataPayload) -> Self {
        value.clone()
    }
}
///`DeviceData`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Device data",
///  "examples": [
///    {
///      "_d": "logger",
///      "_vid": "strato-1",
///      "boot_time": 1660737617.0,
///      "cpu_load": 0.1,
///      "memory_usage": 22.4
///    },
///    {
///      "_d": "diesel_sensor",
///      "_vid": "gamicos-1",
///      "analog": 4.0,
///      "genset_fuel_level_percent": 100.0,
///      "genset_fuel_volume": 3048.625,
///      "level": 0.0
///    }
///  ],
///  "type": "object",
///  "required": [
///    "_vid"
///  ],
///  "properties": {
///    "_d": {
///      "title": "Device key",
///      "examples": [
///        "logger",
///        "apm303",
///        "sma_stp1",
///        "dse855"
///      ],
///      "type": "string"
///    },
///    "_vid": {
///      "title": "Device vendor ID",
///      "description": "Vendor ID of device (must match vendor_id in device table",
///      "examples": [
///        "strato-1",
///        "imt-1",
///        "7a7fcafa-6f07-4c97-9b10-952aad8e9dc4",
///        "35346907"
///      ],
///      "type": "string"
///    }
///  },
///  "additionalProperties": {
///    "type": [
///      "integer",
///      "number",
///      "string",
///      "boolean",
///      "null"
///    ]
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct DeviceData {
    #[serde(
        rename = "_d",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub d: ::std::option::Option<::std::string::String>,
    ///Vendor ID of device (must match vendor_id in device table
    #[serde(rename = "_vid")]
    pub vid: ::std::string::String,
    #[serde(flatten)]
    pub extra: ::std::collections::HashMap<::std::string::String, DeviceDataExtraValue>,
}
impl ::std::convert::From<&DeviceData> for DeviceData {
    fn from(value: &DeviceData) -> Self {
        value.clone()
    }
}
///`DeviceDataExtraValue`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": [
///    "integer",
///    "number",
///    "string",
///    "boolean",
///    "null"
///  ]
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
#[serde(untagged)]
pub enum DeviceDataExtraValue {
    Null,
    Boolean(bool),
    Number(f64),
    String(::std::string::String),
    Integer(i64),
}
impl ::std::convert::From<&Self> for DeviceDataExtraValue {
    fn from(value: &DeviceDataExtraValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for DeviceDataExtraValue {
    fn from(value: bool) -> Self {
        Self::Boolean(value)
    }
}
impl ::std::convert::From<f64> for DeviceDataExtraValue {
    fn from(value: f64) -> Self {
        Self::Number(value)
    }
}
impl ::std::convert::From<i64> for DeviceDataExtraValue {
    fn from(value: i64) -> Self {
        Self::Integer(value)
    }
}
///`Metadata`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Metadata",
///  "examples": [
///    {
///      "config_id": "3e43652",
///      "reading_duration": 93.77299094200134,
///      "snap_rev": 721
///    }
///  ],
///  "type": "object",
///  "properties": {
///    "config_id": {
///      "title": "Configuration ID",
///      "examples": [
///        "3e43652"
///      ],
///      "type": "string"
///    },
///    "data_provider": {
///      "title": "Data provider",
///      "examples": [
///        "sma-hycon-csv"
///      ],
///      "type": "string"
///    },
///    "reading_duration": {
///      "title": "Duration of reading",
///      "examples": [
///        93.77299094200134
///      ],
///      "type": "number"
///    },
///    "snap_rev": {
///      "title": "Snap revision",
///      "examples": [
///        721
///      ],
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct Metadata {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub config_id: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data_provider: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub reading_duration: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub snap_rev: ::std::option::Option<i64>,
}
impl ::std::convert::From<&Metadata> for Metadata {
    fn from(value: &Metadata) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Metadata {
    fn default() -> Self {
        Self {
            config_id: Default::default(),
            data_provider: Default::default(),
            reading_duration: Default::default(),
            snap_rev: Default::default(),
        }
    }
}
