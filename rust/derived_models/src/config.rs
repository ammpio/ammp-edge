// Config types from config.schema.json
// This file is automatically generated by build.rs
// DO NOT EDIT MANUALLY

use crate::driver::{DriverSchema, Typecast};

/// Error types.
pub mod error {
    /// Error from a `TryFrom` or `FromStr` implementation.
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
///This document records the configuration of an AMMP Edge node
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "$id": "https://github.com/ammpio/edge-schema/raw/main/config.schema.json",
///  "title": "AMMP Edge configuration",
///  "description": "This document records the configuration of an AMMP Edge node",
///  "type": "object",
///  "required": [
///    "devices",
///    "readings"
///  ],
///  "properties": {
///    "calc_vendor_id": {
///      "title": "Vendor ID to apply to calculated fields (from 'output')",
///      "examples": [
///        "ws-2"
///      ],
///      "type": "string"
///    },
///    "devices": {
///      "title": "Devices",
///      "examples": [
///        {
///          "dse855_1": {
///            "address": {
///              "host": "192.168.1.215",
///              "mac": "E8:A4:C1:05:19:B2",
///              "port": 502,
///              "unit_id": 1
///            },
///            "device_model": "gen_control_dse",
///            "driver": "deepsea_dse855",
///            "enabled": true,
///            "name": "DSE 855 1",
///            "reading_type": "modbustcp",
///            "vendor_id": "dse-1"
///          },
///          "logger": {
///            "device_model": "gateway_ammp",
///            "driver": "sys_generic",
///            "enabled": true,
///            "name": "Logger",
///            "reading_type": "sys",
///            "vendor_id": "strato-1"
///          },
///          "logger_strato": {
///            "device_model": "gateway_ammp",
///            "driver": "sys_rpi3",
///            "enabled": true,
///            "name": "Logger (StratoPi extension)",
///            "reading_type": "sys",
///            "vendor_id": "strato-1"
///          },
///          "sens_1": {
///            "address": {
///              "baudrate": 9600,
///              "device": "/dev/ttyNS0",
///              "slaveaddr": 1
///            },
///            "device_model": "irr_sens_imt",
///            "driver": "ingburo_ss_rad",
///            "enabled": true,
///            "name": "IMT Sensor 1",
///            "reading_type": "modbusrtu",
///            "vendor_id": "imt-1"
///          },
///          "sma_stp_1": {
///            "address": {
///              "host": "192.168.1.111",
///              "mac": "00:40:AD:A9:E8:85",
///              "port": 502,
///              "unit_id": 3
///            },
///            "device_model": "pv_inv_sma",
///            "driver": "sma_stp25000",
///            "enabled": true,
///            "name": "SMA STP Core 1",
///            "reading_type": "modbustcp",
///            "vendor_id": "3010482707"
///          }
///        }
///      ],
///      "type": "object",
///      "additionalProperties": {
///        "title": "Device",
///        "examples": [
///          {
///            "device_model": "gateway_ammp",
///            "driver": "sys_generic",
///            "enabled": true,
///            "name": "Logger",
///            "reading_type": "sys",
///            "vendor_id": "strato-1"
///          }
///        ],
///        "type": "object",
///        "minProperties": 1,
///        "required": [
///          "driver",
///          "reading_type",
///          "vendor_id"
///        ],
///        "properties": {
///          "address": {
///            "title": "Device address",
///            "examples": [
///              {
///                "host": "192.168.1.215",
///                "mac": "E8:A4:C1:05:19:B2",
///                "port": 502,
///                "unit_id": 1
///              }
///            ],
///            "type": "object",
///            "properties": {
///              "base_url": {
///                "title": "Base URL",
///                "examples": [
///                  "ftp://user:pass@172.16.1.21:900/fsc/log/DataFast/"
///                ],
///                "type": "string"
///              },
///              "baudrate": {
///                "title": "Serial device baud rate",
///                "examples": [
///                  9600
///                ],
///                "type": "integer",
///                "enum": [
///                  2400,
///                  9600,
///                  115200
///                ]
///              },
///              "device": {
///                "title": "Serial device path",
///                "examples": [
///                  "/dev/ttyNS0"
///                ],
///                "type": "string"
///              },
///              "host": {
///                "title": "IP address or hostname",
///                "examples": [
///                  "192.168.1.215"
///                ],
///                "type": "string"
///              },
///              "mac": {
///                "title": "MAC address",
///                "examples": [
///                  "E8:A4:C1:05:19:B2"
///                ],
///                "type": "string"
///              },
///              "port": {
///                "title": "Port",
///                "examples": [
///                  502
///                ],
///                "type": "integer",
///                "max": 65535,
///                "min": 1
///              },
///              "register_offset": {
///                "title": "Modbus register offset",
///                "examples": [
///                  1232
///                ],
///                "type": "integer",
///                "max": 65535,
///                "min": 0
///              },
///              "slaveaddr": {
///                "title": "Serial device unit ID",
///                "examples": [
///                  1
///                ],
///                "type": "integer",
///                "max": 255,
///                "min": 1
///              },
///              "timezone": {
///                "title": "Timezone",
///                "examples": [
///                  "Europe/Amsterdam",
///                  "Africa/Lagos"
///                ],
///                "type": "string"
///              },
///              "unit_id": {
///                "title": "Modbus unit ID",
///                "examples": [
///                  1
///                ],
///                "type": "integer",
///                "max": 255,
///                "min": 1
///              }
///            }
///          },
///          "device_model": {
///            "title": "Device model. Must match device_model_key in device_model table",
///            "description": "Device model",
///            "examples": [
///              "gateway_ammp"
///            ],
///            "type": "string"
///          },
///          "driver": {
///            "title": "Device driver",
///            "examples": [
///              "sys_generic"
///            ],
///            "type": "string"
///          },
///          "enabled": {
///            "title": "Enabled",
///            "default": true,
///            "examples": [
///              true
///            ],
///            "type": "boolean"
///          },
///          "key": {
///            "title": "Key",
///            "default": "",
///            "examples": [
///              "sma_stp_1"
///            ],
///            "type": "string"
///          },
///          "min_read_interval": {
///            "title": "Minimum reading interval (seconds)",
///            "examples": [
///              10
///            ],
///            "type": "integer"
///          },
///          "name": {
///            "title": "Device name",
///            "examples": [
///              "Logger"
///            ],
///            "type": "string"
///          },
///          "reading_type": {
///            "title": "Reading type",
///            "examples": [
///              "modbustcp"
///            ],
///            "type": "string",
///            "enum": [
///              "sys",
///              "modbusrtu",
///              "modbustcp",
///              "mqtt",
///              "rawserial",
///              "rawtcp",
///              "sma_hycon_csv",
///              "sma_speedwire",
///              "snmp"
///            ]
///          },
///          "vendor_id": {
///            "title": "Vendor ID",
///            "examples": [
///              "strato-1"
///            ],
///            "type": "string",
///            "desription": "Vendor ID of device. Must match vendor_id in device table"
///          }
///        }
///      }
///    },
///    "drivers": {
///      "title": "Additional drivers",
///      "additionalProperties": {
///        "$comment": {
///          "ref": "driver.schema.json"
///        }
///      }
///    },
///    "name": {
///      "title": "Config Name",
///      "examples": [
///        "Auto-generated"
///      ],
///      "type": "string"
///    },
///    "output": {
///      "title": "Outputs",
///      "default": [],
///      "type": "array",
///      "items": {
///        "title": "Output",
///        "examples": [
///          {
///            "device": "em210_grid",
///            "field": "P_total",
///            "source": "em210_grid[var = \"P_L1\"].value + em210_grid[var = \"P_L2\"].value + em210_grid[var = \"P_L3\"].value",
///            "typecast": "float"
///          },
///          {
///            "device": "em210_genset",
///            "field": "P_total",
///            "source": "em210_genset[var = \"P_L1\"].value + em210_genset[var = \"P_L2\"].value + em210_genset[var = \"P_L3\"].value",
///            "typecast": "float"
///          }
///        ],
///        "type": "object",
///        "required": [
///          "field",
///          "source",
///          "typecast"
///        ],
///        "properties": {
///          "device": {
///            "title": "Output device",
///            "description": "The device with which to associate the output",
///            "examples": [
///              "dse855_1",
///              "sens_1"
///            ],
///            "type": "string"
///          },
///          "field": {
///            "title": "Output field",
///            "examples": [
///              "P_total",
///              "genset_E",
///              "genset_P",
///              "grid_in_E",
///              "grid_in_P"
///            ],
///            "type": "string"
///          },
///          "source": {
///            "title": "Source",
///            "description": "JSONata expression for source of calculation",
///            "examples": [
///              "em210_grid[var = \"P_L1\"].value + em210_grid[var = \"P_L2\"].value + em210_grid[var = \"P_L3\"].value"
///            ],
///            "type": "string"
///          },
///          "typecast": {
///            "title": "Typecast",
///            "description": "Typecast of output",
///            "examples": [
///              "int",
///              "float"
///            ],
///            "type": "string",
///            "enum": [
///              "int",
///              "float",
///              "str",
///              "bool"
///            ]
///          }
///        }
///      }
///    },
///    "read_interval": {
///      "title": "Interval between readings (seconds)",
///      "default": 60,
///      "examples": [
///        60
///      ],
///      "type": "integer"
///    },
///    "read_roundtime": {
///      "title": "Read at round times (based on interval duration)",
///      "default": false,
///      "examples": [
///        true
///      ],
///      "type": "boolean"
///    },
///    "readings": {
///      "title": "Readings to take",
///      "examples": [
///        {
///          "genset_1_E": {
///            "device": "dse855_1",
///            "var": "E"
///          },
///          "genset_1_P": {
///            "device": "dse855_1",
///            "var": "P"
///          },
///          "genset_1_S": {
///            "device": "dse855_1",
///            "var": "S"
///          },
///          "pvinv1_P_L1": {
///            "device": "sma_stp_1",
///            "var": "P_L1"
///          },
///          "pvinv1_P_L2": {
///            "device": "sma_stp_1",
///            "var": "P_L2"
///          },
///          "pvinv1_P_L3": {
///            "device": "sma_stp_1",
///            "var": "P_L3"
///          },
///          "sens_2_irradiance": {
///            "device": "sens_2",
///            "var": "irradiance"
///          }
///        }
///      ],
///      "type": "object",
///      "additionalProperties": {
///        "title": "Reading schema",
///        "examples": [
///          {
///            "device": "sens_1",
///            "var": "temp_ext"
///          }
///        ],
///        "type": "object",
///        "required": [
///          "device",
///          "var"
///        ],
///        "properties": {
///          "device": {
///            "title": "Device key (matches 'devices' object)",
///            "examples": [
///              "sens_1"
///            ],
///            "type": "string"
///          },
///          "var": {
///            "title": "Variable key (matches device driver)",
///            "examples": [
///              "temp_ext"
///            ],
///            "type": "string"
///          }
///        }
///      }
///    },
///    "status_readings": {
///      "title": "Status readings",
///      "description": "Pairs of device key and status info key that should be read out",
///      "type": "array",
///      "items": {
///        "type": "object",
///        "properties": {
///          "d": {
///            "title": "Device key",
///            "examples": [
///              "dse855_1",
///              "sens_1"
///            ],
///            "type": "string"
///          },
///          "r": {
///            "title": "Status info key",
///            "examples": [
///              "oil_pressure"
///            ],
///            "type": "string"
///          }
///        }
///      }
///    },
///    "timestamp": {
///      "title": "Timestamp",
///      "description": "Timestamp of config",
///      "examples": [
///        "2022-07-30T06:07:48Z"
///      ],
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct AmmpEdgeConfiguration {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub calc_vendor_id: ::std::option::Option<::std::string::String>,
    pub devices: ::std::collections::HashMap<::std::string::String, Device>,
    #[serde(default, skip_serializing_if = "::std::collections::HashMap::is_empty")]
    pub drivers: ::std::collections::HashMap<::std::string::String, DriverSchema>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub output: ::std::vec::Vec<Output>,
    #[serde(default = "defaults::default_u64::<i64, 60>")]
    pub read_interval: i64,
    #[serde(default)]
    pub read_roundtime: bool,
    pub readings: ::std::collections::HashMap<::std::string::String, ReadingSchema>,
    ///Pairs of device key and status info key that should be read out
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub status_readings: ::std::vec::Vec<StatusReadingsItem>,
    ///Timestamp of config
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timestamp: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&AmmpEdgeConfiguration> for AmmpEdgeConfiguration {
    fn from(value: &AmmpEdgeConfiguration) -> Self {
        value.clone()
    }
}
///`Device`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Device",
///  "examples": [
///    {
///      "device_model": "gateway_ammp",
///      "driver": "sys_generic",
///      "enabled": true,
///      "name": "Logger",
///      "reading_type": "sys",
///      "vendor_id": "strato-1"
///    }
///  ],
///  "type": "object",
///  "minProperties": 1,
///  "required": [
///    "driver",
///    "reading_type",
///    "vendor_id"
///  ],
///  "properties": {
///    "address": {
///      "title": "Device address",
///      "examples": [
///        {
///          "host": "192.168.1.215",
///          "mac": "E8:A4:C1:05:19:B2",
///          "port": 502,
///          "unit_id": 1
///        }
///      ],
///      "type": "object",
///      "properties": {
///        "base_url": {
///          "title": "Base URL",
///          "examples": [
///            "ftp://user:pass@172.16.1.21:900/fsc/log/DataFast/"
///          ],
///          "type": "string"
///        },
///        "baudrate": {
///          "title": "Serial device baud rate",
///          "examples": [
///            9600
///          ],
///          "type": "integer",
///          "enum": [
///            2400,
///            9600,
///            115200
///          ]
///        },
///        "device": {
///          "title": "Serial device path",
///          "examples": [
///            "/dev/ttyNS0"
///          ],
///          "type": "string"
///        },
///        "host": {
///          "title": "IP address or hostname",
///          "examples": [
///            "192.168.1.215"
///          ],
///          "type": "string"
///        },
///        "mac": {
///          "title": "MAC address",
///          "examples": [
///            "E8:A4:C1:05:19:B2"
///          ],
///          "type": "string"
///        },
///        "port": {
///          "title": "Port",
///          "examples": [
///            502
///          ],
///          "type": "integer",
///          "max": 65535,
///          "min": 1
///        },
///        "register_offset": {
///          "title": "Modbus register offset",
///          "examples": [
///            1232
///          ],
///          "type": "integer",
///          "max": 65535,
///          "min": 0
///        },
///        "slaveaddr": {
///          "title": "Serial device unit ID",
///          "examples": [
///            1
///          ],
///          "type": "integer",
///          "max": 255,
///          "min": 1
///        },
///        "timezone": {
///          "title": "Timezone",
///          "examples": [
///            "Europe/Amsterdam",
///            "Africa/Lagos"
///          ],
///          "type": "string"
///        },
///        "unit_id": {
///          "title": "Modbus unit ID",
///          "examples": [
///            1
///          ],
///          "type": "integer",
///          "max": 255,
///          "min": 1
///        }
///      }
///    },
///    "device_model": {
///      "title": "Device model. Must match device_model_key in device_model table",
///      "description": "Device model",
///      "examples": [
///        "gateway_ammp"
///      ],
///      "type": "string"
///    },
///    "driver": {
///      "title": "Device driver",
///      "examples": [
///        "sys_generic"
///      ],
///      "type": "string"
///    },
///    "enabled": {
///      "title": "Enabled",
///      "default": true,
///      "examples": [
///        true
///      ],
///      "type": "boolean"
///    },
///    "key": {
///      "title": "Key",
///      "default": "",
///      "examples": [
///        "sma_stp_1"
///      ],
///      "type": "string"
///    },
///    "min_read_interval": {
///      "title": "Minimum reading interval (seconds)",
///      "examples": [
///        10
///      ],
///      "type": "integer"
///    },
///    "name": {
///      "title": "Device name",
///      "examples": [
///        "Logger"
///      ],
///      "type": "string"
///    },
///    "reading_type": {
///      "title": "Reading type",
///      "examples": [
///        "modbustcp"
///      ],
///      "type": "string",
///      "enum": [
///        "sys",
///        "modbusrtu",
///        "modbustcp",
///        "mqtt",
///        "rawserial",
///        "rawtcp",
///        "sma_hycon_csv",
///        "sma_speedwire",
///        "snmp"
///      ]
///    },
///    "vendor_id": {
///      "title": "Vendor ID",
///      "examples": [
///        "strato-1"
///      ],
///      "type": "string",
///      "desription": "Vendor ID of device. Must match vendor_id in device table"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct Device {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub address: ::std::option::Option<DeviceAddress>,
    ///Device model
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub device_model: ::std::option::Option<::std::string::String>,
    pub driver: ::std::string::String,
    #[serde(default = "defaults::default_bool::<true>")]
    pub enabled: bool,
    #[serde(default)]
    pub key: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub min_read_interval: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    pub reading_type: ReadingType,
    pub vendor_id: ::std::string::String,
}
impl ::std::convert::From<&Device> for Device {
    fn from(value: &Device) -> Self {
        value.clone()
    }
}
///`DeviceAddress`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Device address",
///  "examples": [
///    {
///      "host": "192.168.1.215",
///      "mac": "E8:A4:C1:05:19:B2",
///      "port": 502,
///      "unit_id": 1
///    }
///  ],
///  "type": "object",
///  "properties": {
///    "base_url": {
///      "title": "Base URL",
///      "examples": [
///        "ftp://user:pass@172.16.1.21:900/fsc/log/DataFast/"
///      ],
///      "type": "string"
///    },
///    "baudrate": {
///      "title": "Serial device baud rate",
///      "examples": [
///        9600
///      ],
///      "type": "integer",
///      "enum": [
///        2400,
///        9600,
///        115200
///      ]
///    },
///    "device": {
///      "title": "Serial device path",
///      "examples": [
///        "/dev/ttyNS0"
///      ],
///      "type": "string"
///    },
///    "host": {
///      "title": "IP address or hostname",
///      "examples": [
///        "192.168.1.215"
///      ],
///      "type": "string"
///    },
///    "mac": {
///      "title": "MAC address",
///      "examples": [
///        "E8:A4:C1:05:19:B2"
///      ],
///      "type": "string"
///    },
///    "port": {
///      "title": "Port",
///      "examples": [
///        502
///      ],
///      "type": "integer",
///      "max": 65535,
///      "min": 1
///    },
///    "register_offset": {
///      "title": "Modbus register offset",
///      "examples": [
///        1232
///      ],
///      "type": "integer",
///      "max": 65535,
///      "min": 0
///    },
///    "slaveaddr": {
///      "title": "Serial device unit ID",
///      "examples": [
///        1
///      ],
///      "type": "integer",
///      "max": 255,
///      "min": 1
///    },
///    "timezone": {
///      "title": "Timezone",
///      "examples": [
///        "Europe/Amsterdam",
///        "Africa/Lagos"
///      ],
///      "type": "string"
///    },
///    "unit_id": {
///      "title": "Modbus unit ID",
///      "examples": [
///        1
///      ],
///      "type": "integer",
///      "max": 255,
///      "min": 1
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct DeviceAddress {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub base_url: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub baudrate: ::std::option::Option<SerialDeviceBaudRate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub device: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub host: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mac: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub port: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub register_offset: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub slaveaddr: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timezone: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub unit_id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&DeviceAddress> for DeviceAddress {
    fn from(value: &DeviceAddress) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DeviceAddress {
    fn default() -> Self {
        Self {
            base_url: Default::default(),
            baudrate: Default::default(),
            device: Default::default(),
            host: Default::default(),
            mac: Default::default(),
            port: Default::default(),
            register_offset: Default::default(),
            slaveaddr: Default::default(),
            timezone: Default::default(),
            unit_id: Default::default(),
        }
    }
}
///`Output`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Output",
///  "examples": [
///    {
///      "device": "em210_grid",
///      "field": "P_total",
///      "source": "em210_grid[var = \"P_L1\"].value + em210_grid[var = \"P_L2\"].value + em210_grid[var = \"P_L3\"].value",
///      "typecast": "float"
///    },
///    {
///      "device": "em210_genset",
///      "field": "P_total",
///      "source": "em210_genset[var = \"P_L1\"].value + em210_genset[var = \"P_L2\"].value + em210_genset[var = \"P_L3\"].value",
///      "typecast": "float"
///    }
///  ],
///  "type": "object",
///  "required": [
///    "field",
///    "source",
///    "typecast"
///  ],
///  "properties": {
///    "device": {
///      "title": "Output device",
///      "description": "The device with which to associate the output",
///      "examples": [
///        "dse855_1",
///        "sens_1"
///      ],
///      "type": "string"
///    },
///    "field": {
///      "title": "Output field",
///      "examples": [
///        "P_total",
///        "genset_E",
///        "genset_P",
///        "grid_in_E",
///        "grid_in_P"
///      ],
///      "type": "string"
///    },
///    "source": {
///      "title": "Source",
///      "description": "JSONata expression for source of calculation",
///      "examples": [
///        "em210_grid[var = \"P_L1\"].value + em210_grid[var = \"P_L2\"].value + em210_grid[var = \"P_L3\"].value"
///      ],
///      "type": "string"
///    },
///    "typecast": {
///      "title": "Typecast",
///      "description": "Typecast of output",
///      "examples": [
///        "int",
///        "float"
///      ],
///      "type": "string",
///      "enum": [
///        "int",
///        "float",
///        "str",
///        "bool"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct Output {
    ///The device with which to associate the output
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub device: ::std::option::Option<::std::string::String>,
    pub field: ::std::string::String,
    ///JSONata expression for source of calculation
    pub source: ::std::string::String,
    ///Typecast of output
    pub typecast: Typecast,
}
impl ::std::convert::From<&Output> for Output {
    fn from(value: &Output) -> Self {
        value.clone()
    }
}
///`ReadingSchema`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Reading schema",
///  "examples": [
///    {
///      "device": "sens_1",
///      "var": "temp_ext"
///    }
///  ],
///  "type": "object",
///  "required": [
///    "device",
///    "var"
///  ],
///  "properties": {
///    "device": {
///      "title": "Device key (matches 'devices' object)",
///      "examples": [
///        "sens_1"
///      ],
///      "type": "string"
///    },
///    "var": {
///      "title": "Variable key (matches device driver)",
///      "examples": [
///        "temp_ext"
///      ],
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct ReadingSchema {
    pub device: ::std::string::String,
    pub var: ::std::string::String,
}
impl ::std::convert::From<&ReadingSchema> for ReadingSchema {
    fn from(value: &ReadingSchema) -> Self {
        value.clone()
    }
}
///`ReadingType`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Reading type",
///  "examples": [
///    "modbustcp"
///  ],
///  "type": "string",
///  "enum": [
///    "sys",
///    "modbusrtu",
///    "modbustcp",
///    "mqtt",
///    "rawserial",
///    "rawtcp",
///    "sma_hycon_csv",
///    "sma_speedwire",
///    "snmp"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum ReadingType {
    #[serde(rename = "sys")]
    Sys,
    #[serde(rename = "modbusrtu")]
    Modbusrtu,
    #[serde(rename = "modbustcp")]
    Modbustcp,
    #[serde(rename = "mqtt")]
    Mqtt,
    #[serde(rename = "rawserial")]
    Rawserial,
    #[serde(rename = "rawtcp")]
    Rawtcp,
    #[serde(rename = "sma_hycon_csv")]
    SmaHyconCsv,
    #[serde(rename = "sma_speedwire")]
    SmaSpeedwire,
    #[serde(rename = "snmp")]
    Snmp,
}
impl ::std::convert::From<&Self> for ReadingType {
    fn from(value: &ReadingType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReadingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Sys => f.write_str("sys"),
            Self::Modbusrtu => f.write_str("modbusrtu"),
            Self::Modbustcp => f.write_str("modbustcp"),
            Self::Mqtt => f.write_str("mqtt"),
            Self::Rawserial => f.write_str("rawserial"),
            Self::Rawtcp => f.write_str("rawtcp"),
            Self::SmaHyconCsv => f.write_str("sma_hycon_csv"),
            Self::SmaSpeedwire => f.write_str("sma_speedwire"),
            Self::Snmp => f.write_str("snmp"),
        }
    }
}
impl ::std::str::FromStr for ReadingType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "sys" => Ok(Self::Sys),
            "modbusrtu" => Ok(Self::Modbusrtu),
            "modbustcp" => Ok(Self::Modbustcp),
            "mqtt" => Ok(Self::Mqtt),
            "rawserial" => Ok(Self::Rawserial),
            "rawtcp" => Ok(Self::Rawtcp),
            "sma_hycon_csv" => Ok(Self::SmaHyconCsv),
            "sma_speedwire" => Ok(Self::SmaSpeedwire),
            "snmp" => Ok(Self::Snmp),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReadingType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReadingType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReadingType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///`SerialDeviceBaudRate`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Serial device baud rate",
///  "examples": [
///    9600
///  ],
///  "type": "integer",
///  "enum": [
///    2400,
///    9600,
///    115200
///  ]
///}
/// ```
/// </details>
#[derive(::serde::Serialize, Clone, Debug, PartialEq)]
#[serde(transparent)]
pub struct SerialDeviceBaudRate(i64);
impl ::std::ops::Deref for SerialDeviceBaudRate {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SerialDeviceBaudRate> for i64 {
    fn from(value: SerialDeviceBaudRate) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SerialDeviceBaudRate> for SerialDeviceBaudRate {
    fn from(value: &SerialDeviceBaudRate) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SerialDeviceBaudRate {
    type Error = self::error::ConversionError;
    fn try_from(
        value: i64,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![2400_i64, 9600_i64, 115200_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SerialDeviceBaudRate {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| { <D::Error as ::serde::de::Error>::custom(e.to_string()) })
    }
}
///`StatusReadingsItem`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "d": {
///      "title": "Device key",
///      "examples": [
///        "dse855_1",
///        "sens_1"
///      ],
///      "type": "string"
///    },
///    "r": {
///      "title": "Status info key",
///      "examples": [
///        "oil_pressure"
///      ],
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct StatusReadingsItem {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub d: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub r: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&StatusReadingsItem> for StatusReadingsItem {
    fn from(value: &StatusReadingsItem) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StatusReadingsItem {
    fn default() -> Self {
        Self {
            d: Default::default(),
            r: Default::default(),
        }
    }
}
/// Generation of default values for serde.
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
    pub(super) fn default_u64<T, const V: u64>() -> T
    where
        T: ::std::convert::TryFrom<u64>,
        <T as ::std::convert::TryFrom<u64>>::Error: ::std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
}

