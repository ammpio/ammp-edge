// Driver types from driver.schema.json
// This file is automatically generated by build.rs
// DO NOT EDIT MANUALLY

/// Error types.
pub mod error {
    /// Error from a `TryFrom` or `FromStr` implementation.
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
///Bit order, if extracting part of register
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Bit order",
///  "description": "Bit order, if extracting part of register",
///  "type": "string",
///  "enum": [
///    "lsb",
///    "msb"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BitOrder {
    #[serde(rename = "lsb")]
    Lsb,
    #[serde(rename = "msb")]
    Msb,
}
impl ::std::convert::From<&Self> for BitOrder {
    fn from(value: &BitOrder) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BitOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Lsb => f.write_str("lsb"),
            Self::Msb => f.write_str("msb"),
        }
    }
}
impl ::std::str::FromStr for BitOrder {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "lsb" => Ok(Self::Lsb),
            "msb" => Ok(Self::Msb),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BitOrder {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BitOrder {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BitOrder {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///`CommonModbusReadingOpts`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Common Modbus reading opts",
///  "type": "object",
///  "properties": {
///    "bit_order": {
///      "title": "Bit order",
///      "description": "Bit order, if extracting part of register",
///      "type": "string",
///      "enum": [
///        "lsb",
///        "msb"
///      ]
///    },
///    "fncode": {
///      "title": "Function code",
///      "description": "Modbus function code",
///      "examples": [
///        3,
///        4
///      ],
///      "type": "integer",
///      "format": "u8"
///    },
///    "length_bits": {
///      "title": "Length in bits",
///      "description": "Length in bits, if extracting part of register",
///      "type": "integer",
///      "format": "u8",
///      "maximum": 16.0,
///      "minimum": 1.0
///    },
///    "order": {
///      "title": "Register order",
///      "description": "Register order when parsing multi-register readings",
///      "type": "string",
///      "enum": [
///        "msr",
///        "lsr"
///      ]
///    },
///    "register": {
///      "title": "Register",
///      "description": "Modbus register",
///      "type": "integer",
///      "format": "u16",
///      "maximum": 65535.0,
///      "minimum": 0.0
///    },
///    "start_bit": {
///      "title": "Start bit",
///      "description": "Start bit, if extracting part of register",
///      "type": "integer",
///      "format": "u8",
///      "maximum": 15.0,
///      "minimum": 0.0
///    },
///    "words": {
///      "title": "Words",
///      "description": "Number of 2-byte words for Modbus",
///      "examples": [
///        2
///      ],
///      "type": "integer",
///      "format": "u16",
///      "maximum": 4.0,
///      "minimum": 1.0
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct CommonModbusReadingOpts {
    ///Bit order, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bit_order: ::std::option::Option<BitOrder>,
    ///Modbus function code
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fncode: ::std::option::Option<u8>,
    ///Length in bits, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length_bits: ::std::option::Option<::std::num::NonZeroU16>,
    ///Register order when parsing multi-register readings
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub order: ::std::option::Option<RegisterOrder>,
    ///Modbus register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub register: ::std::option::Option<u16>,
    ///Start bit, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_bit: ::std::option::Option<u8>,
    ///Number of 2-byte words for Modbus
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub words: ::std::option::Option<::std::num::NonZeroU16>,
}
impl ::std::convert::From<&CommonModbusReadingOpts> for CommonModbusReadingOpts {
    fn from(value: &CommonModbusReadingOpts) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CommonModbusReadingOpts {
    fn default() -> Self {
        Self {
            bit_order: Default::default(),
            fncode: Default::default(),
            length_bits: Default::default(),
            order: Default::default(),
            register: Default::default(),
            start_bit: Default::default(),
            words: Default::default(),
        }
    }
}
///`CommonMqttReadingOpts`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Common MQTT reading opts",
///  "type": "object",
///  "properties": {
///    "parse_as": {
///      "title": "Parse input as",
///      "description": "Parse data based on serialization of readout",
///      "type": "string",
///      "enum": [
///        "bytes",
///        "str",
///        "hex"
///      ]
///    },
///    "topic": {
///      "title": "Topic",
///      "description": "MQTT topic to subscribe to",
///      "examples": [
///        "sensor/temperature"
///      ],
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct CommonMqttReadingOpts {
    ///Parse data based on serialization of readout
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse_as: ::std::option::Option<ParseInputAs>,
    ///MQTT topic to subscribe to
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub topic: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CommonMqttReadingOpts> for CommonMqttReadingOpts {
    fn from(value: &CommonMqttReadingOpts) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CommonMqttReadingOpts {
    fn default() -> Self {
        Self {
            parse_as: Default::default(),
            topic: Default::default(),
        }
    }
}
///Source type of data being read
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Data type",
///  "description": "Source type of data being read",
///  "examples": [
///    "int16"
///  ],
///  "type": "string",
///  "enum": [
///    "int16",
///    "uint16",
///    "int32",
///    "uint32",
///    "int64",
///    "uint64",
///    "float",
///    "double"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum DataType {
    #[serde(rename = "int16")]
    Int16,
    #[serde(rename = "uint16")]
    Uint16,
    #[serde(rename = "int32")]
    Int32,
    #[serde(rename = "uint32")]
    Uint32,
    #[serde(rename = "int64")]
    Int64,
    #[serde(rename = "uint64")]
    Uint64,
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "double")]
    Double,
}
impl ::std::convert::From<&Self> for DataType {
    fn from(value: &DataType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Int16 => f.write_str("int16"),
            Self::Uint16 => f.write_str("uint16"),
            Self::Int32 => f.write_str("int32"),
            Self::Uint32 => f.write_str("uint32"),
            Self::Int64 => f.write_str("int64"),
            Self::Uint64 => f.write_str("uint64"),
            Self::Float => f.write_str("float"),
            Self::Double => f.write_str("double"),
        }
    }
}
impl ::std::str::FromStr for DataType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "int16" => Ok(Self::Int16),
            "uint16" => Ok(Self::Uint16),
            "int32" => Ok(Self::Int32),
            "uint32" => Ok(Self::Uint32),
            "int64" => Ok(Self::Int64),
            "uint64" => Ok(Self::Uint64),
            "float" => Ok(Self::Float),
            "double" => Ok(Self::Double),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///`DriverSchema`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "$id": "https://github.com/ammpio/edge-schema/raw/main/driver.schema.json",
///  "title": "Driver schema",
///  "type": "object",
///  "required": [
///    "fields"
///  ],
///  "properties": {
///    "common": {
///      "title": "Common parameters for each field",
///      "default": {},
///      "examples": [
///        {
///          "datatype": "float",
///          "fncode": 4,
///          "words": 2
///        }
///      ],
///      "$ref": "#/definitions/field_opts"
///    },
///    "fields": {
///      "title": "Fields to be read",
///      "type": "object",
///      "additionalProperties": {
///        "$ref": "#/definitions/field_opts"
///      }
///    },
///    "status_info": {
///      "title": "Status info items to be read",
///      "type": "object",
///      "additionalProperties": {
///        "$ref": "#/definitions/status_info_opts"
///      }
///    },
///    "status_info_common": {
///      "title": "Common status info parameters",
///      "default": {},
///      "$ref": "#/definitions/status_info_opts"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct DriverSchema {
    #[serde(default = "defaults::driver_schema_common")]
    pub common: FieldOpts,
    pub fields: ::std::collections::HashMap<::std::string::String, FieldOpts>,
    #[serde(default, skip_serializing_if = ":: std :: collections :: HashMap::is_empty")]
    pub status_info: ::std::collections::HashMap<::std::string::String, StatusInfoOpts>,
    #[serde(default = "defaults::driver_schema_status_info_common")]
    pub status_info_common: StatusInfoOpts,
}
impl ::std::convert::From<&DriverSchema> for DriverSchema {
    fn from(value: &DriverSchema) -> Self {
        value.clone()
    }
}
///`FieldOpts`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "allOf": [
///    {
///      "$ref": "#/definitions/common_modbus_reading_opts"
///    },
///    {
///      "$ref": "#/definitions/common_mqtt_reading_opts"
///    },
///    {
///      "title": "Field specific opts",
///      "type": "object",
///      "properties": {
///        "datamap": {
///          "title": "Data map",
///          "description": "Mapping between source (hex) and final value",
///          "type": "object"
///        },
///        "datatype": {
///          "title": "Data type",
///          "description": "Source type of data being read",
///          "examples": [
///            "int16"
///          ],
///          "type": "string",
///          "enum": [
///            "int16",
///            "uint16",
///            "int32",
///            "uint32",
///            "int64",
///            "uint64",
///            "float",
///            "double"
///          ]
///        },
///        "description": {
///          "title": "Description of reading (not used for data processing)",
///          "type": "string"
///        },
///        "multiplier": {
///          "title": "Multiplier",
///          "description": "Reading multiplier (applied before offset)",
///          "type": "number"
///        },
///        "offset": {
///          "title": "Reading offset (applied after multiplier)",
///          "type": "number"
///        },
///        "typecast": {
///          "title": "Typecast",
///          "description": "Typecast for final processed reading",
///          "examples": [
///            "int"
///          ],
///          "type": "string",
///          "enum": [
///            "int",
///            "float",
///            "str",
///            "bool"
///          ]
///        },
///        "unit": {
///          "title": "Unit of reading (not used for data processing)",
///          "type": "string"
///        }
///      }
///    }
///  ]
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct FieldOpts {
    ///Bit order, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bit_order: ::std::option::Option<BitOrder>,
    ///Mapping between source (hex) and final value
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub datamap: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    ///Source type of data being read
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datatype: ::std::option::Option<DataType>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    ///Modbus function code
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fncode: ::std::option::Option<u8>,
    ///Length in bits, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length_bits: ::std::option::Option<::std::num::NonZeroU16>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub multiplier: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<f64>,
    ///Register order when parsing multi-register readings
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub order: ::std::option::Option<RegisterOrder>,
    ///Parse data based on serialization of readout
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse_as: ::std::option::Option<ParseInputAs>,
    ///Modbus register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub register: ::std::option::Option<u16>,
    ///Start bit, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_bit: ::std::option::Option<u8>,
    ///MQTT topic to subscribe to
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub topic: ::std::option::Option<::std::string::String>,
    ///Typecast for final processed reading
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub typecast: ::std::option::Option<Typecast>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub unit: ::std::option::Option<::std::string::String>,
    ///Number of 2-byte words for Modbus
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub words: ::std::option::Option<::std::num::NonZeroU16>,
}
impl ::std::convert::From<&FieldOpts> for FieldOpts {
    fn from(value: &FieldOpts) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for FieldOpts {
    fn default() -> Self {
        Self {
            bit_order: Default::default(),
            datamap: Default::default(),
            datatype: Default::default(),
            description: Default::default(),
            fncode: Default::default(),
            length_bits: Default::default(),
            multiplier: Default::default(),
            offset: Default::default(),
            order: Default::default(),
            parse_as: Default::default(),
            register: Default::default(),
            start_bit: Default::default(),
            topic: Default::default(),
            typecast: Default::default(),
            unit: Default::default(),
            words: Default::default(),
        }
    }
}
///`NumericStatusLevel`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Numeric Status Level",
///  "type": "integer",
///  "format": "u8",
///  "enum": [
///    0,
///    1,
///    2,
///    3,
///    4
///  ]
///}
/// ```
/// </details>
#[derive(::serde::Serialize, Clone, Debug, PartialEq)]
#[serde(transparent)]
pub struct NumericStatusLevel(u8);
impl ::std::ops::Deref for NumericStatusLevel {
    type Target = u8;
    fn deref(&self) -> &u8 {
        &self.0
    }
}
impl ::std::convert::From<NumericStatusLevel> for u8 {
    fn from(value: NumericStatusLevel) -> Self {
        value.0
    }
}
impl ::std::convert::From<&NumericStatusLevel> for NumericStatusLevel {
    fn from(value: &NumericStatusLevel) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<u8> for NumericStatusLevel {
    type Error = self::error::ConversionError;
    fn try_from(
        value: u8,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![0_u8, 1_u8, 2_u8, 3_u8, 4_u8].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for NumericStatusLevel {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<u8>::deserialize(deserializer)?)
            .map_err(|e| { <D::Error as ::serde::de::Error>::custom(e.to_string()) })
    }
}
///Parse data based on serialization of readout
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Parse input as",
///  "description": "Parse data based on serialization of readout",
///  "type": "string",
///  "enum": [
///    "bytes",
///    "str",
///    "hex"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum ParseInputAs {
    #[serde(rename = "bytes")]
    Bytes,
    #[serde(rename = "str")]
    Str,
    #[serde(rename = "hex")]
    Hex,
}
impl ::std::convert::From<&Self> for ParseInputAs {
    fn from(value: &ParseInputAs) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ParseInputAs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bytes => f.write_str("bytes"),
            Self::Str => f.write_str("str"),
            Self::Hex => f.write_str("hex"),
        }
    }
}
impl ::std::str::FromStr for ParseInputAs {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "bytes" => Ok(Self::Bytes),
            "str" => Ok(Self::Str),
            "hex" => Ok(Self::Hex),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ParseInputAs {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ParseInputAs {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ParseInputAs {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///Register order when parsing multi-register readings
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Register order",
///  "description": "Register order when parsing multi-register readings",
///  "type": "string",
///  "enum": [
///    "msr",
///    "lsr"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum RegisterOrder {
    #[serde(rename = "msr")]
    Msr,
    #[serde(rename = "lsr")]
    Lsr,
}
impl ::std::convert::From<&Self> for RegisterOrder {
    fn from(value: &RegisterOrder) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RegisterOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Msr => f.write_str("msr"),
            Self::Lsr => f.write_str("lsr"),
        }
    }
}
impl ::std::str::FromStr for RegisterOrder {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "msr" => Ok(Self::Msr),
            "lsr" => Ok(Self::Lsr),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RegisterOrder {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RegisterOrder {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RegisterOrder {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///`StatusInfoOpts`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Status info opts",
///  "examples": [
///    {
///      "oil_pressure": {
///        "content": "Low Oil Pressure",
///        "length_bits": 4,
///        "register": 2049,
///        "start_bit": 0
///      }
///    }
///  ],
///  "type": "object",
///  "additionalProperties": {
///    "allOf": [
///      {
///        "$ref": "#/definitions/common_modbus_reading_opts"
///      },
///      {
///        "title": "Status info specific opts",
///        "type": "object",
///        "properties": {
///          "content": {
///            "title": "Content",
///            "description": "Content for the status info",
///            "examples": [
///              "Low Oil Pressure",
///              "High Temperature"
///            ],
///            "type": "string"
///          },
///          "status_level_value_map": {
///            "title": "Status level value map",
///            "description": "List of pairs that defines how to map a value to a status level (0=OK, 4=Critical)",
///            "examples": [
///              [
///                [
///                  0,
///                  0
///                ],
///                [
///                  1,
///                  3
///                ]
///              ]
///            ],
///            "type": "array",
///            "items": {
///              "type": "array",
///              "items": [
///                {
///                  "title": "Value",
///                  "type": "integer",
///                  "format": "u8"
///                },
///                {
///                  "title": "Numeric Status Level",
///                  "type": "integer",
///                  "format": "u8",
///                  "enum": [
///                    0,
///                    1,
///                    2,
///                    3,
///                    4
///                  ]
///                }
///              ],
///              "maxItems": 2,
///              "minItems": 2
///            }
///          }
///        }
///      }
///    ]
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
#[serde(transparent)]
pub struct StatusInfoOpts(
    pub ::std::collections::HashMap<::std::string::String, StatusInfoOptsValue>,
);
impl ::std::ops::Deref for StatusInfoOpts {
    type Target = ::std::collections::HashMap<
        ::std::string::String,
        StatusInfoOptsValue,
    >;
    fn deref(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, StatusInfoOptsValue> {
        &self.0
    }
}
impl ::std::convert::From<StatusInfoOpts>
for ::std::collections::HashMap<::std::string::String, StatusInfoOptsValue> {
    fn from(value: StatusInfoOpts) -> Self {
        value.0
    }
}
impl ::std::convert::From<&StatusInfoOpts> for StatusInfoOpts {
    fn from(value: &StatusInfoOpts) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<
    ::std::collections::HashMap<::std::string::String, StatusInfoOptsValue>,
> for StatusInfoOpts {
    fn from(
        value: ::std::collections::HashMap<::std::string::String, StatusInfoOptsValue>,
    ) -> Self {
        Self(value)
    }
}
///`StatusInfoOptsValue`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "allOf": [
///    {
///      "$ref": "#/definitions/common_modbus_reading_opts"
///    },
///    {
///      "title": "Status info specific opts",
///      "type": "object",
///      "properties": {
///        "content": {
///          "title": "Content",
///          "description": "Content for the status info",
///          "examples": [
///            "Low Oil Pressure",
///            "High Temperature"
///          ],
///          "type": "string"
///        },
///        "status_level_value_map": {
///          "title": "Status level value map",
///          "description": "List of pairs that defines how to map a value to a status level (0=OK, 4=Critical)",
///          "examples": [
///            [
///              [
///                0,
///                0
///              ],
///              [
///                1,
///                3
///              ]
///            ]
///          ],
///          "type": "array",
///          "items": {
///            "type": "array",
///            "items": [
///              {
///                "title": "Value",
///                "type": "integer",
///                "format": "u8"
///              },
///              {
///                "title": "Numeric Status Level",
///                "type": "integer",
///                "format": "u8",
///                "enum": [
///                  0,
///                  1,
///                  2,
///                  3,
///                  4
///                ]
///              }
///            ],
///            "maxItems": 2,
///            "minItems": 2
///          }
///        }
///      }
///    }
///  ]
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct StatusInfoOptsValue {
    ///Bit order, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bit_order: ::std::option::Option<BitOrder>,
    ///Content for the status info
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub content: ::std::option::Option<::std::string::String>,
    ///Modbus function code
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fncode: ::std::option::Option<u8>,
    ///Length in bits, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length_bits: ::std::option::Option<::std::num::NonZeroU16>,
    ///Register order when parsing multi-register readings
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub order: ::std::option::Option<RegisterOrder>,
    ///Modbus register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub register: ::std::option::Option<u16>,
    ///Start bit, if extracting part of register
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub start_bit: ::std::option::Option<u8>,
    ///List of pairs that defines how to map a value to a status level (0=OK, 4=Critical)
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub status_level_value_map: ::std::vec::Vec<(u8, NumericStatusLevel)>,
    ///Number of 2-byte words for Modbus
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub words: ::std::option::Option<::std::num::NonZeroU16>,
}
impl ::std::convert::From<&StatusInfoOptsValue> for StatusInfoOptsValue {
    fn from(value: &StatusInfoOptsValue) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StatusInfoOptsValue {
    fn default() -> Self {
        Self {
            bit_order: Default::default(),
            content: Default::default(),
            fncode: Default::default(),
            length_bits: Default::default(),
            order: Default::default(),
            register: Default::default(),
            start_bit: Default::default(),
            status_level_value_map: Default::default(),
            words: Default::default(),
        }
    }
}
///Typecast for final processed reading
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Typecast",
///  "description": "Typecast for final processed reading",
///  "examples": [
///    "int"
///  ],
///  "type": "string",
///  "enum": [
///    "int",
///    "float",
///    "str",
///    "bool"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum Typecast {
    #[serde(rename = "int")]
    Int,
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "str")]
    Str,
    #[serde(rename = "bool")]
    Bool,
}
impl ::std::convert::From<&Self> for Typecast {
    fn from(value: &Typecast) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Typecast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Int => f.write_str("int"),
            Self::Float => f.write_str("float"),
            Self::Str => f.write_str("str"),
            Self::Bool => f.write_str("bool"),
        }
    }
}
impl ::std::str::FromStr for Typecast {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "int" => Ok(Self::Int),
            "float" => Ok(Self::Float),
            "str" => Ok(Self::Str),
            "bool" => Ok(Self::Bool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Typecast {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Typecast {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Typecast {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
/// Generation of default values for serde.
pub mod defaults {
    pub(super) fn driver_schema_common() -> super::FieldOpts {
        super::FieldOpts {
            bit_order: Default::default(),
            datamap: Default::default(),
            datatype: Default::default(),
            description: Default::default(),
            fncode: Default::default(),
            length_bits: Default::default(),
            multiplier: Default::default(),
            offset: Default::default(),
            order: Default::default(),
            parse_as: Default::default(),
            register: Default::default(),
            start_bit: Default::default(),
            topic: Default::default(),
            typecast: Default::default(),
            unit: Default::default(),
            words: Default::default(),
        }
    }
    pub(super) fn driver_schema_status_info_common() -> super::StatusInfoOpts {
        super::StatusInfoOpts([].into_iter().collect())
    }
}

