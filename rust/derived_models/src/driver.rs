// Driver types from driver.schema.json
// This file is automatically generated by build.rs
// DO NOT EDIT MANUALLY

/// Error types.
pub mod error {
    /// Error from a `TryFrom` or `FromStr` implementation.
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
///`CommonParametersForEachField`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Common parameters for each field",
///  "default": {},
///  "examples": [
///    {
///      "datatype": "float",
///      "fncode": 4,
///      "words": 2
///    }
///  ],
///  "type": "object",
///  "properties": {
///    "datatype": {
///      "title": "Source type of data being read",
///      "examples": [
///        "int16"
///      ],
///      "type": "string",
///      "enum": [
///        "int16",
///        "uint16",
///        "int32",
///        "uint32",
///        "int64",
///        "uint64",
///        "float",
///        "double"
///      ]
///    },
///    "fncode": {
///      "title": "Modbus function code",
///      "default": 3,
///      "examples": [
///        3,
///        4
///      ],
///      "type": "integer"
///    },
///    "typecast": {
///      "title": "Typecast for final processed reading",
///      "examples": [
///        "int"
///      ],
///      "type": "string",
///      "enum": [
///        "int",
///        "float",
///        "str",
///        "bool"
///      ]
///    },
///    "words": {
///      "title": "Number of 2-byte words for Modbus",
///      "examples": [
///        2
///      ],
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct CommonParametersForEachField {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datatype: ::std::option::Option<SourceTypeOfDataBeingRead>,
    #[serde(default = "defaults::default_u64::<i64, 3>")]
    pub fncode: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub typecast: ::std::option::Option<TypecastForFinalProcessedReading>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub words: ::std::option::Option<i64>,
}
impl ::std::convert::From<&CommonParametersForEachField>
for CommonParametersForEachField {
    fn from(value: &CommonParametersForEachField) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CommonParametersForEachField {
    fn default() -> Self {
        CommonParametersForEachField {
            datatype: Default::default(),
            fncode: Default::default(),
            typecast: Default::default(),
            words: Default::default(),
        }
    }
}
///`DriverSchema`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "$id": "https://github.com/ammpio/edge-schema/raw/main/driver.schema.json",
///  "title": "Driver schema",
///  "type": "object",
///  "required": [
///    "fields"
///  ],
///  "properties": {
///    "common": {
///      "title": "Common parameters for each field",
///      "default": {},
///      "examples": [
///        {
///          "datatype": "float",
///          "fncode": 4,
///          "words": 2
///        }
///      ],
///      "type": "object",
///      "properties": {
///        "datatype": {
///          "title": "Source type of data being read",
///          "examples": [
///            "int16"
///          ],
///          "type": "string",
///          "enum": [
///            "int16",
///            "uint16",
///            "int32",
///            "uint32",
///            "int64",
///            "uint64",
///            "float",
///            "double"
///          ]
///        },
///        "fncode": {
///          "title": "Modbus function code",
///          "default": 3,
///          "examples": [
///            3,
///            4
///          ],
///          "type": "integer"
///        },
///        "typecast": {
///          "title": "Typecast for final processed reading",
///          "examples": [
///            "int"
///          ],
///          "type": "string",
///          "enum": [
///            "int",
///            "float",
///            "str",
///            "bool"
///          ]
///        },
///        "words": {
///          "title": "Number of 2-byte words for Modbus",
///          "examples": [
///            2
///          ],
///          "type": "integer"
///        }
///      }
///    },
///    "fields": {
///      "title": "Fields to be read",
///      "type": "object",
///      "additionalProperties": {
///        "type": "object",
///        "properties": {
///          "datamap": {
///            "title": "Mapping between source and final value",
///            "type": "object"
///          },
///          "datatype": {
///            "title": "Source type of data being read",
///            "examples": [
///              "int16"
///            ],
///            "type": "string",
///            "enum": [
///              "int16",
///              "uint16",
///              "int32",
///              "uint32",
///              "int64",
///              "uint64",
///              "float",
///              "double"
///            ]
///          },
///          "description": {
///            "title": "Description of reading (not used for data processing)",
///            "type": "string"
///          },
///          "fncode": {
///            "title": "Modbus function code",
///            "default": 3,
///            "examples": [
///              3,
///              4
///            ],
///            "type": "integer"
///          },
///          "multiplier": {
///            "title": "Reading multiplier (applied before offset)",
///            "type": "number"
///          },
///          "offset": {
///            "title": "Reading offset (applied after multiplier)",
///            "type": "number"
///          },
///          "register": {
///            "title": "Modbus start register",
///            "type": "integer"
///          },
///          "typecast": {
///            "title": "Typecast for final processed reading",
///            "examples": [
///              "int"
///            ],
///            "type": "string",
///            "enum": [
///              "int",
///              "float",
///              "str",
///              "bool"
///            ]
///          },
///          "unit": {
///            "title": "Unit of reading (not used for data processing)",
///            "type": "string"
///          },
///          "words": {
///            "title": "Number of 2-byte words for Modbus",
///            "examples": [
///              2
///            ],
///            "type": "integer"
///          }
///        }
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct DriverSchema {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub common: ::std::option::Option<CommonParametersForEachField>,
    pub fields: ::std::collections::HashMap<
        ::std::string::String,
        DriverSchemaFieldsValue,
    >,
}
impl ::std::convert::From<&DriverSchema> for DriverSchema {
    fn from(value: &DriverSchema) -> Self {
        value.clone()
    }
}
///`DriverSchemaFieldsValue`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "datamap": {
///      "title": "Mapping between source and final value",
///      "type": "object"
///    },
///    "datatype": {
///      "title": "Source type of data being read",
///      "examples": [
///        "int16"
///      ],
///      "type": "string",
///      "enum": [
///        "int16",
///        "uint16",
///        "int32",
///        "uint32",
///        "int64",
///        "uint64",
///        "float",
///        "double"
///      ]
///    },
///    "description": {
///      "title": "Description of reading (not used for data processing)",
///      "type": "string"
///    },
///    "fncode": {
///      "title": "Modbus function code",
///      "default": 3,
///      "examples": [
///        3,
///        4
///      ],
///      "type": "integer"
///    },
///    "multiplier": {
///      "title": "Reading multiplier (applied before offset)",
///      "type": "number"
///    },
///    "offset": {
///      "title": "Reading offset (applied after multiplier)",
///      "type": "number"
///    },
///    "register": {
///      "title": "Modbus start register",
///      "type": "integer"
///    },
///    "typecast": {
///      "title": "Typecast for final processed reading",
///      "examples": [
///        "int"
///      ],
///      "type": "string",
///      "enum": [
///        "int",
///        "float",
///        "str",
///        "bool"
///      ]
///    },
///    "unit": {
///      "title": "Unit of reading (not used for data processing)",
///      "type": "string"
///    },
///    "words": {
///      "title": "Number of 2-byte words for Modbus",
///      "examples": [
///        2
///      ],
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, PartialEq)]
pub struct DriverSchemaFieldsValue {
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub datamap: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datatype: ::std::option::Option<SourceTypeOfDataBeingRead>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default = "defaults::default_u64::<i64, 3>")]
    pub fncode: i64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub multiplier: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub register: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub typecast: ::std::option::Option<TypecastForFinalProcessedReading>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub unit: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub words: ::std::option::Option<i64>,
}
impl ::std::convert::From<&DriverSchemaFieldsValue> for DriverSchemaFieldsValue {
    fn from(value: &DriverSchemaFieldsValue) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DriverSchemaFieldsValue {
    fn default() -> Self {
        Self {
            datamap: Default::default(),
            datatype: Default::default(),
            description: Default::default(),
            fncode: defaults::default_u64::<i64, 3>(),
            multiplier: Default::default(),
            offset: Default::default(),
            register: Default::default(),
            typecast: Default::default(),
            unit: Default::default(),
            words: Default::default(),
        }
    }
}
///`SourceTypeOfDataBeingRead`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Source type of data being read",
///  "examples": [
///    "int16"
///  ],
///  "type": "string",
///  "enum": [
///    "int16",
///    "uint16",
///    "int32",
///    "uint32",
///    "int64",
///    "uint64",
///    "float",
///    "double"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum SourceTypeOfDataBeingRead {
    #[serde(rename = "int16")]
    Int16,
    #[serde(rename = "uint16")]
    Uint16,
    #[serde(rename = "int32")]
    Int32,
    #[serde(rename = "uint32")]
    Uint32,
    #[serde(rename = "int64")]
    Int64,
    #[serde(rename = "uint64")]
    Uint64,
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "double")]
    Double,
}
impl ::std::convert::From<&Self> for SourceTypeOfDataBeingRead {
    fn from(value: &SourceTypeOfDataBeingRead) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SourceTypeOfDataBeingRead {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Int16 => f.write_str("int16"),
            Self::Uint16 => f.write_str("uint16"),
            Self::Int32 => f.write_str("int32"),
            Self::Uint32 => f.write_str("uint32"),
            Self::Int64 => f.write_str("int64"),
            Self::Uint64 => f.write_str("uint64"),
            Self::Float => f.write_str("float"),
            Self::Double => f.write_str("double"),
        }
    }
}
impl ::std::str::FromStr for SourceTypeOfDataBeingRead {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "int16" => Ok(Self::Int16),
            "uint16" => Ok(Self::Uint16),
            "int32" => Ok(Self::Int32),
            "uint32" => Ok(Self::Uint32),
            "int64" => Ok(Self::Int64),
            "uint64" => Ok(Self::Uint64),
            "float" => Ok(Self::Float),
            "double" => Ok(Self::Double),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SourceTypeOfDataBeingRead {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SourceTypeOfDataBeingRead {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SourceTypeOfDataBeingRead {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///`TypecastForFinalProcessedReading`
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Typecast for final processed reading",
///  "examples": [
///    "int"
///  ],
///  "type": "string",
///  "enum": [
///    "int",
///    "float",
///    "str",
///    "bool"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum TypecastForFinalProcessedReading {
    #[serde(rename = "int")]
    Int,
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "str")]
    Str,
    #[serde(rename = "bool")]
    Bool,
}
impl ::std::convert::From<&Self> for TypecastForFinalProcessedReading {
    fn from(value: &TypecastForFinalProcessedReading) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TypecastForFinalProcessedReading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Int => f.write_str("int"),
            Self::Float => f.write_str("float"),
            Self::Str => f.write_str("str"),
            Self::Bool => f.write_str("bool"),
        }
    }
}
impl ::std::str::FromStr for TypecastForFinalProcessedReading {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "int" => Ok(Self::Int),
            "float" => Ok(Self::Float),
            "str" => Ok(Self::Str),
            "bool" => Ok(Self::Bool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TypecastForFinalProcessedReading {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for TypecastForFinalProcessedReading {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for TypecastForFinalProcessedReading {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
/// Generation of default values for serde.
pub mod defaults {
    pub(super) fn default_u64<T, const V: u64>() -> T
    where
        T: ::std::convert::TryFrom<u64>,
        <T as ::std::convert::TryFrom<u64>>::Error: ::std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
}

